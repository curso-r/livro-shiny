```{r, echo = FALSE}
knitr::opts_chunk$set(
  fig.align = "center"
)
```

# Debug

Na programação, *debug*^[Também conhecido como *debugging* (depuração, em português).] se refere ao processo de encontrar e corrigir erros em códigos. 

No desenvolvimento de aplicativos Shiny, esse processo é um pouco mais complicado em comparação com outras utilizações da linguagem R (como a construção de um gráfico ou o ajuste de um modelo). Isso porque nem sempre conseguimos rodar diretamente o código que estamos escrevendo. A maior parte do código só pode ser avaliado com o app em funcionamento, o que nos obriga a de fato rodar o app para verificar se tudo vai funcionar. No entanto, quando encontramos um erro, nem sempre fica claro onde ele aconteceu.

Neste capítulo descreveremos erros comuns do desenvolvimento de aplicativos Shiny e apresentaremos estratégias para facilitar o processo de debug.

## Erros comuns

A seguir, listamos erros que cometemos frequentemente quando estamos programando em Shiny. Alguns acontecem mais quando estamos começando a programar em Shiny, outros vão nos seguir ao longo de toda a jornada.

##### Erros comuns de programação em R

Erros comuns de programação em R, como chamar objetos ou funções inexistentes, operações não permitidas ou utilização inadequada de funções costumam devolver mensagens de erro informativas no Console. O primeiro passo para resolver esses problemas é ler a mensagem de erro. Caso a mensagem não te dê informação o suficiente para corrigir o erro, sempre vale a pena jogar a mensagem no Google e buscar pela resposta em fóruns de dúvidas.

##### Erros de sintaxe do Shiny

Em geral, o app não roda e receberemos a mensagem de erro `unexpected symbol`. Esses erros são causados principalmente por falta ou excesso de vírgulas, parênteses ou chaves. 

##### Erros de reatividade

Esses erros violam premissas do Shiny, impedindo o Shiny de construir o diagrama de reatividade.

A principal causa é utilizar um valor reativo ou avaliar uma expressão reativa fora de um *consumidor reativo*, isto é, uma função que *observa* valores reativos. O app não vai rodar e você verá a seguinte mensagem de erro `Can't access reactive value 'tamanho' outside of reactive consumer..`.

Outro erro de reatividade muito comum é esquecer os parênteses ao chamar uma expressão reativa (objeto criado pelas funções `reactive()` e `eventReactive()`). Normalmente receberemos uma mensagem indicando que a classe de algum objeto está errada, como  `'x' must be numeric` ou a famosa mensagem `cannot coerce type 'closure' to vector of type ...`.

Outras causas dizem respeito a utilização das listas `input` e `output`.

Você só pode *ler* valores da lista `input`. Se você tentar gravar um valor diretamente, será retornado um erro. Isso acontece porque a lista `input` deve sempre uma *cópia* das ações do usuário no navegador, uma premissa para que o diagrama de reatividade funcione de forma correta para atualizar os valores na tela.

Você só pode *escrever* valores na lista `output`. Se você tentar ler um valor, será retornado um erro. A lista `output` não contém os valores devolvidos para as funções `render*()` , mas sim o conteúdo transformado por essas funções para ser inserido no HTML.

##### Violação de outras premissas do Shiny

Um erro comum é não fazer a correspondência certa entre as funções `_Output()` e `render_()`. O app vai rodar, mas a visualização não ser mostrada. Em algumas situações, uma mensagem de erro será retornada. Em outras, o erro será silencioso.

Também não é raro errarmos o nome de um input (usar um input que não existe). O app vai rodar e, geralmente, retornar um erro relacionado a uma função receber um valor que não deveria ser `NULL` (já que o objeto `input` é uma lista e acessar um elemento que não existe em uma lista retorna o valor `NULL`).

Se errarmos o nome de um output, o app vai rodar e não vai retornar erro. O output não será gerado. Nesse caso, estamos apenas criando uma visualização que não aparece em nenhum lugar no app.

Já quando usamos o mesmo ID para dois outputs, o app vai rodar e não vai retornar erro. Os dois outputs não serão gerados.

## Encontrando erros 

### O bom e velho método `print`

### A função `browser()`

Quando as mensagens de erro não nos ajudarem, podemos usar a função `browser()` para espiarmos o que está acontecendo dentro do server. 

Basta colocar essa função onde você suspeita que o erro está acontecendo e, ao rodar o app, você poderá utilizar o Console para avaliar os objetos que estiverem no Environment. 

Enquanto a função `browser()` estiver ativa, o app ficará congelado.

```{r, eval=FALSE}
# server
valor_reativo <- reactive({
  sample(1:10, 1)
})

output$plot <- renderPlot({
  browser() #<<
  hist(rnorm(100, valor_reativo, 1))
})

```

```{r}
# No console

# Browse[1]> valor_reativo()
# [1] 4
```

Embora você possa colocar a função browser em qualquer lugar no server, é melhor colocá-la dentro de uma função reativa. Caso contrário, o `browser()` só será chamado na inicialização do app e você não conseguirá avaliar valores reativos.

Veja o exemplo a seguir.

```{r, eval=FALSE}
# server
amostra <- reactive({
  sample(1:10, input$n)
})

browser() #<<

output$plot <- renderPlot({
  amostra() |> 
    table() |> 
    barplot()
})

```

```{r}
# No console

# Browse[1]> amostra()
#Error : Can't access reactive value 'amostra' outside of reactive consumer.
```

